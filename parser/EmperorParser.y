{
{-|
Module      : EmperorParser
Description : Parser for the emperor language
Copyright   : (c) Edward Jones, 2019
License     : GPL-3
Maintainer  : Edward Jones
Stability   : experimental
Portability : POSIX
Language    : Haskell2010

This module defines the machinery to parse the Emperor language from a token stream generated by the Emperor lexer.
-}
module EmperorParser (parseEmperor) where

import AST
import EmperorLexer (Alex, Token(..), lexWrap, alexError, runAlex)
import Types.Results (EmperorType(..), Purity(..))

}


%name parseEmperor ast
-- %name parseHeader body
-- %name parseREPL 
-- TODO: Add a repl parser

%error { parseError }
%lexer { lexWrap } { TEoF }
%monad { Alex }
%tokentype { Token }

-- Enforce perfection
-- %expect 0

%token
    DOCASSIGNMENTLINE   { TDocAssignmentLine    _ }
    DOCLINE             { TDocLine              _ }
    INT                 { TInteger              intVal _ }
    BOOL                { TBool                 isTrue _ }
    REAL                { TReal                 realVal _ }
    CHAR                { TChar                 charVal _ }
    "if"                { TIf                   _ }
    "else"              { TElse                 _ }
    "while"             { TWhile                _ }
    "repeat"            { TRepeat               _ }
    "with"              { TWith                 _ }
    "switch"            { TSwitch               _ }
    "for"               { TFor                  _ }
    "import"            { TImport               _ }
    "module"            { TModule               _ }
    IDENT               { TIdent                identifierVal _ }
    "<-"                { TQueue                _ }
    "->"                { TGoesTo               _ }
    "="                 { TGets                 _ }
    "("                 { TLParenth             _ }
    ")"                 { TRParenth             _ }
    "["                 { TLBracket             _ }
    "]"                 { TRBracket             _ }
    "{"                 { TLBrace               _ }
    "}"                 { TRBrace               _ }
    "+"                 { TPlus                 _ }
    "-"                 { TMinus                _ }
    "/"                 { TDivide               _ }
    "%"                 { TModulo               _ }
    "*"                 { TTimes                _ }
    "<<"                { TShiftLeft            _ }
    ">>"                { TShiftRight           _ }
    ">>>"               { TShiftRightSameSign   _ }
    "&"                 { TAndScrict            _ }
    "&&"                { TAndLazy              _ }
    "|"                 { TOrStrict             _ }
    "||"                { TOrLazy               _ }
    "!"                 { TNot                  _ }
    "^"                 { TXor                  _ }
    "<"                 { TLessThan             _ }
    "<="                { TLessThanOrEqual      _ }
    ">"                 { TGreaterThan          _ }
    ">="                { TGreaterThanOrEqual   _ }
    "=>"                { TImplies              _ }
    "=="                { TEqual                _ }
    "!="                { TNotEqual             _ }
    "@"                 { TImpure               _ }
    ","                 { TComma                _ }
    "int"               { TIntT                 _ }
    "bool"              { TBoolT                _ }
    "real"              { TRealT                _ }
    "char"              { TCharT                _ }
    "()"                { TUnit                 _ }
    "Any"               { TAnyT                 _ }
    "<:"                { TIsSubType            _ }
    "<~"                { TIsImplementeBy       _ }
    "::"                { TIsType               _ }
    "class"             { TClass                _ }
    "component"         { TComponent            _ }
    TABS                { TTabs                 numTabs _ }
    "_"                 { TIDC                  _ }
    EOL                 { TEoL                  _ }

%left CALL
%right "->"
%left "||"
%left "&&"
%left "|"
%left "^"
%left "&"
%left "=>"
%left "==" "!="
%left "<" "<=" ">" ">="
%left "<<" ">>" ">>>"
%left "+" "-"
%left "*" "/" "%"
%right NEG "!"
%right "@"
%nonassoc "{" "[" "(" INT REAL CHAR BOOL IDENT

%%

ast :: {AST}
ast : moduleHeader usings moduleBody                  { AST $1 $2 $3 }

moduleHeader :: {ModuleHeader}
moduleHeader : "module" IDENT EOL { Module (Ident (identifierVal $2)) }

-- maybeDocs :: {Maybe [DocLine]}
-- maybeDocs : {- empty -} { Nothing }
--           | docs        { Just $1 }

-- docs :: {[DocLine]}
-- docs : DOCLINE          { [ $1] }
--      | DOCLINE EOL docs { $1 : $3 }

usings :: {[Import]}
usings : {- empty -}    { [] }
       | using usings   { $1 : $2 }

using :: {Import}
using : "import" usingLabel                      { Import $2 Nothing }
      | "import" usingLabel "(" sepList(",", IDENT) ")"    { Import $2 (Just ([(\x -> (Ident (identifierVal x)))] <*> $4))}

usingLabel :: {ImportLocation}
usingLabel : "<" IDENT ">" { ImportLocation Global (Ident (identifierVal $2)) }
        --    | STRING            { ImportLocation Local (Ident (stringVal $1)) }

-- identList :: {[Ident]}
-- identList : IDENT               { [Ident (identifierVal $1)]}
--           | IDENT "," identList { Ident (identifierVal $1) : $3 }

moduleBody :: {[ModuleItem]}
moduleBody : moduleItem             { [$1] }
           | moduleItem moduleBody  { $1 : $2 }

moduleItem :: {ModuleItem}
moduleItem : component    { $1 }
           | typeClass    { $1 }
           | functionDef  { $1 }

component :: {ModuleItem}
component : "component" IDENT maybe(typeComparison) EOL body { Component (Ident (identifierVal $2)) $3 $5 }

typeClass :: {ModuleItem}
typeClass : "class" IDENT maybe(typeComparison) EOL body { TypeClass (Ident (identifierVal $2)) $3 $5 }

functionDef :: {ModuleItem}
functionDef : IDENT "::" typedef EOL IDENT functionParamDef EOL body { FunctionDef (Ident (identifierVal $1)) $3 $6 $8 }

functionParamDef :: {[Ident]}
functionParamDef : {- empty -}              { [] }
                 | IDENT functionParamDef   { (Ident (identifierVal $1)) : $2 }

typedef :: {EmperorType}
typedef : "int"                 { IntP }
        | "bool"                { CharP }
        | "real"                { RealP }
        | "char"                { BoolP }
        | "()"                  { Unit }
        | "Any"                 { Any }
        | "(" typedef ")"       { $2 }
        | typedef "->" typedef  { EFunction Impure $1 $3 } 
        | tupleTypeDef          { ETuple $1 } 
        | "[" typedef "]"       { EList $2 }
        | "{" typedef "}"       { ESet $2 }
        -- | IDENT                 { Ident }

tupleTypeDef :: {[EmperorType]}
tupleTypeDef : typedef              { [$1] }
             | typedef "*" tupleTypeDef  { $1 : $3 }

-- maybeTypeComparison :: {Maybe [TypeComparison]}
-- maybeTypeComparison : {- empty -}       { Nothing }
--                     | typeComparison    { Just $1 }

typeComparisons :: {[TypeComparison]}
typeComparisons : typeComparison                    { [$1] }
                | typeComparison typeComparisons    { $1 : $2 }

typeComparison :: {TypeComparison}
typeComparison : "<:" IDENT            { IsSubType (Ident (identifierVal $2)) }
               | "<:" IDENT "<~" IDENT { IsSubTypeWithImplementor (Ident (identifierVal $2)) (Ident (identifierVal $4)) }

body :: {[BodyBlock]}
body : sepList(EOL, bodyBlock)  { $1 }
     -- | bodyBlock EOL body { $1 : $3 }

bodyBlock :: {BodyBlock}
bodyBlock : bodyLine                                    { Line $1 }
          | "if" expr EOL body "else" body              { IfElse $2 $4 $6 }
          | "while" expr EOL body                       { While $2 $4 }
          | "for" IDENT "<-" expr EOL body              { For (Ident (identifierVal $2)) $4 $6 }
          | "repeat" expr EOL body                      { Repeat $2 $4 }
          | "with" assignment EOL body                  { With $2 $4 }
          | "switch" expr EOL sepList(EOL, switchCase)  { Switch $2 $4 }

-- switchBody :: {[SwitchCase]}
-- switchBody : {- empty -}    { [] }
--            | switchCase EOL switchBody { $1 : $3 }

switchCase :: {SwitchCase}
switchCase : expr "->" bodyBlock    { SwitchCase $1 $3 }

bodyLine :: {BodyLine}
bodyLine : indentation bodyLineContent {BodyLine $1 $2}

bodyLineContent :: {BodyLineContent}
bodyLineContent : assignment            { AssignmentC $1 }
                | queue                 { QueueC $1 }
                | partialCall           { CallC $1 }

assignment :: {Assignment}
assignment : IDENT "=" expr { Assignment (Ident (identifierVal $1)) $3 } 

queue :: {Queue}
queue : IDENT "<-" expr { Queue (Ident (identifierVal $1)) $3 }

expr :: {Expr}
expr : value                            { Value $1 }
     | "!" expr                         { Not $2 }
     | "-" expr %prec NEG               { Neg $2 }
     | expr "+" expr                    { Add $1 $3 }
     | expr "-" expr                    { Subtract $1 $3 }
     | expr "*" expr                    { Multiply $1 $3 }
     | expr "/" expr                    { Divide $1 $3 }
     | expr "%" expr                    { Modulo $1 $3 }
     | expr "<" expr                    { Less $1 $3 }
     | expr "<=" expr                   { LessOrEqual $1 $3 }
     | expr ">" expr                    { Greater $1 $3 }
     | expr ">=" expr                   { GreaterOrEqual $1 $3 }
     | expr "==" expr                   { Equal $1 $3 }
     | expr "!=" expr                   { NotEqual $1 $3 }
     | expr "&" expr                    { AndStrict $1 $3 }
     | expr "&&" expr                   { AndLazy $1 $3 }
     | expr "|" expr                    { OrStrict $1 $3 }
     | expr "||" expr                   { OrLazy $1 $3 }
     | expr "=>" expr                   { Implies $1 $3 }
     | expr "^" expr                    { Xor $1 $3 }
     | expr "<<" expr                   { ShiftLeft $1 $3 }
     | expr ">>" expr                   { ShiftRight $1 $3 }
     | expr ">>>" expr                  { ShiftRightSameSign $1 $3 }
     | "{" sepList(",", expr) "}"                  { Set $2 }
     | "(" sepList1(",", expr) ")"                 { Tuple $2 }
     | "[" sepList(",", expr) "]"                  { List $2 }

exprs :: {[Expr]}
exprs : {- empty -}     {[]}
      | expr exprs      {$1 : $2}

-- exprList :: {[Expr]}
-- exprList : {- empty -}          { [] }
--          | exprListNonZero      { $1 }

-- exprListNonZero :: {[Expr]}
-- exprListNonZero : expr                      { [$1] }
--                 | expr "," exprListNonZero  { $1 : $3 }

indentation :: {Tabs}
indentation : {- empty -} { Tabs 0 }
            | TABS        { Tabs (numTabs $1) }

value :: {Value}
value : "_"         { IDC }
      | INT         { Integer (intVal $1) }
      | REAL        { Real (realVal $1)}
    --   | IDENT       { IdentV (identifierVal $1) }
      | CHAR        { Char (charVal $1) }
      | BOOL        { Bool (isTrue $1) }
      | partialCall %prec CALL { Call $1 }

partialCall :: {PartialCall}
partialCall : partialCall expr %prec CALL { PartialApplication $1 $2 }
            | "@" IDENT        { CallIdentifier Impure (Ident (identifierVal $2)) }
            | IDENT            { CallIdentifier Pure (Ident (identifierVal $1)) }

-- TODO: Type these
-- TODO: make whitespace lists the same as sepLists?
maybe(p) : {- empty -} { Nothing }
         | p           { Just $1 }

whitespaceList(p) : {- empty -}         { [] }
                  | p whitespaceList(p) { $1 : $2 }

whitespaceList1(p) : p                      { [$1] }
                   | p whitespaceList(p)    { $1 : $2 }

sepList(p,q) : {- empty -}          { [] }
             | p q sepList1(p,q)   { $1 : $2 }

sepList1(p,q) : p                   { [$1] }
              | p q sepList1(p,q)  { $1 : $2 }

{

parseError :: Token -> Alex a
parseError t = alexError $ "Parser error on token " ++ show t

}
